\section{Introduction}

In our previous work \cite{benchmark_chapter}, we focused on the physical problem, mathematical formulation, statement of the benchmark problems and design of numerical experiments. We now provide the code for numerical experiments, using open source libraries, with the objective of validating or reproducing the results and smooth handover of numerical software to future developers as per best practices \cite{software_handover_paper}.

\section{Prerequisites}

We use python 3.6.9 as the programming language. In this project we use the libraries :
\begin{itemize}
\item FEniCS 2019.1.0 (\cite{fenics1},\cite{fenics2},\cite{dolfin1},\cite{dolfin2}, www.fenicsproject.org)
\item RBniCS 0.1.dev1 (\cite{crbm},www.rbnicsproject.org)
\item Matplolib 3.1.2 (\cite{matplotlib},www.matplotlib.org)
\item numpy 1.17.4 (\cite{numpy},www.numpy.org)
\end{itemize}

\begin{python}
from dolfin import * #FEniCS library
from mshr import * #mshr - mesh generation component of FEniCS
from rbnics import * #RBniCS library
import matplotlib.pyplot as plt #Matplotlib library
import numpy as np #Numpy library
\end{python}

The solutions are stored in .pvd format, which can later be viewed with Paraview (www.paraview.org).

\section{Installation}

Simply clone the public repository:

\begin{lstlisting}[language=bash]
git clone https://github.com/ROMSOC/benchmark_thermomechanical_model
\end{lstlisting}


\section{Running the benchmark cases}

Source codes for input data are provided in the folder \emph{source\_files}. Source codes for running the benchmark are provided in folder \emph{source}. After running the benchmark, results are stored in folder \emph{result\_files}.

Run required .py file e.g. \emph{file\_name.py} as,
\begin{python}
python3 file_name.py
\end{python}

\section{Benchmark cases}

\subsection{Reading the mesh}

We first construct the polygonal domain using mshr.
\begin{python}
# Define domain
domain = Polygon([Point(0.,0.),Point(7.05,0.),
				Point(7.05,7.265),Point(5.3,7.265),
				Point(5.3,4.065),Point(4.95,4.065),
				Point(4.95,3.565),Point(4.6,3.565),
				Point(4.6,2.965),Point(4.25,2.965),
				Point(4.25,2.365),Point(0.,2.365)])
\end{python}

The domain is divided into triangular subdomains. We define the mapping from the reference domain to the parametrized domain. As an example, we take the subdomain 1 whose coordinates on reference domain are $(0,0),(4.25,0),(0,2.365)$. It is deformed to the parametrized subdomain with coordinates $(0,0),(\mu_6,2),(0,\mu_0)$. The $\mu_6$ and $\mu_0$ are the $6$th and $0$th parameter of zero-indexed tuple $\Xi$. This mapping can be defined as,
\begin{python}
	{
		("0", "0"): ("0", "0"),
		("4.25", "0"): ("mu[6]/2", "0"),
		("0", "2.365"): ("0", "mu[0]")
	}, # subdomain 1
\end{python}

The RBniCS computes the mapping for each subdomain and uses it during affine transformation of operators. Similarly, the mappings and subdomains are created for other $29$ subdomains.

Next, we set the subdomain marker:
\begin{python}
# Loop over all mappings and set subdomain markers
for i, vertices_mapping in enumerate(vertices_mappings):
	print(i,vertices_mapping.keys())
	subdomain_i = Polygon([Point(*[float(coord) for coord in vertex]) for vertex in counterclockwise(vertices_mapping.keys())])
	domain.set_subdomain(i + 1, subdomain_i)
\end{python}

The mesh and subdomains are created based on subdomain markers.
\begin{python}
# Create mesh
mesh = generate_mesh(domain, 30) #30 specifies the mesh size.

# Create subdomains
subdomains = MeshFunction("size_t", mesh, 2, mesh.domains())
\end{python}

We now set the boundary markers. Since our boundaries are divided across $20$ subdomains and these boundaries are later reclassified into $5$ different boundaries, we define $20$ classes and set markers for each of these boundaries. For example, for the boundary $\gamma_s$, we define the class
\begin{python}
class Gamma_s(SubDomain):
	def inside(self, x, on_boundary):
		return x[0] < DOLFIN_EPS and on_boundary
\end{python}
and create an instant of this class and set boundary marker as $1$.
\begin{python}
gamma_s = Gamma_s()
gamma_s.mark(boundaries, 1)
\end{python}

Unlike $\gamma_s$, the bottom boundary $\gamma_-$ is shared by $5$ subdomains, we define $5$ different classes and correspondingly $5$ different markers.

\begin{python}
class Gamma_minus1(SubDomain):
	def inside(self, x, on_boundary):
		return x[1] < DOLFIN_EPS and x[0] < (4.255 + DOLFIN_EPS) and on_boundary

class Gamma_minus2(SubDomain):
	def inside(self, x, on_boundary):
		return x[1] < DOLFIN_EPS and x[0] > (4.2 - DOLFIN_EPS) and x[0] < (4.65 + DOLFIN_EPS) and on_boundary

class Gamma_minus3(SubDomain):
	def inside(self, x, on_boundary):
		return x[1] < DOLFIN_EPS and x[0] > (4.55 - DOLFIN_EPS) and x[0] < (5.05 + DOLFIN_EPS) and on_boundary

class Gamma_minus4(SubDomain):
	def inside(self, x, on_boundary):
		return x[1] < DOLFIN_EPS and x[0] > (4.9 - DOLFIN_EPS) and x[0] < (5.4 + DOLFIN_EPS) and on_boundary

class Gamma_minus5(SubDomain):
	def inside(self, x, on_boundary):
		return x[1] < DOLFIN_EPS and x[0] > (5.25 - DOLFIN_EPS) and x[0] < (7.15 + DOLFIN_EPS) and on_boundary
\end{python}

\begin{python}
gamma_minus1 = Gamma_minus1()
gamma_minus1.mark(boundaries, 2)
gamma_minus2 = Gamma_minus2()
gamma_minus2.mark(boundaries, 3)
gamma_minus3 = Gamma_minus3()
gamma_minus3.mark(boundaries, 4)
gamma_minus4 = Gamma_minus4()
gamma_minus4.mark(boundaries, 5)
gamma_minus5 = Gamma_minus5()
gamma_minus5.mark(boundaries, 6)
\end{python}

In a similar manner, markers are set for other boundaries and the mesh, boundary markers, subdomain markers and affine maps are stored. 

\begin{python}
# Save mesh data
os.system("mkdir ../input_data/mesh_data")
VerticesMappingIO.save_file(vertices_mappings, ".", "../data_files/mesh_data/hearth_vertices_mapping.vmp")
File("../data_files/mesh_data/hearth.xml") << mesh
File("../data_files/mesh_data/hearth_physical_region.xml") << subdomains
File("../data_files/mesh_data/hearth_facet_region.xml") << boundaries
XDMFFile("../data_files/mesh_data/hearth.xdmf").write(mesh)
XDMFFile("../data_files/mesh_data/hearth_physical_region.xdmf").write(subdomains)
XDMFFile("../data_files/mesh_data/hearth_facet_region.xdmf").write(boundaries)
File("../data_files/mesh_data/hearth.pvd") << mesh
File("../data_files/mesh_data/hearth_physical_region.pvd") << subdomains
File("../data_files/mesh_data/hearth_facet_region.pvd") << boundaries
\end{python}

At the beginning of any benchmark test, we first read the mesh, which is divided into subdomains and also read the boundary markers. The volume of each subdomains and length of each boundary are measured. Notice that all boundary markers with same boundary condition are combined.

\begin{python}
# Read the mesh file from specified path.
mesh = Mesh("../../benchmarks/data_files/mesh_data/hearth.xml")
domains = MeshFunction('size_t',mesh,mesh.topology().dim()) # Read domain marker
subdomains = MeshFunction("size_t", mesh, "../../benchmarks/data_files/mesh_data/hearth_physical_region.xml") # Read subdomain markers
boundaries = MeshFunction("size_t", mesh, "../../benchmarks/data_files/mesh_data/hearth_facet_region.xml") # Read boundary markers
dx = Measure('dx', domain = mesh, subdomain_data = domains) # Volume measure
ds = Measure('ds', domain = mesh, subdomain_data = boundaries) # Boundary measure
n = as_vector(FacetNormal(mesh)) # Edge unit normal vector

d_bottom = ds(2) + ds(3) + ds(4) + ds(5) + ds(6) # Markers of bottom boundary \gamma_{-}
d_out = ds(7) + ds(8) + ds(9) + ds(10) + ds(11) # Markers of outer boundary \gamma_{out}
d_sf = ds(13) + ds(14) + ds(15) + ds(16) + ds(17) + ds(18) + ds(19) + ds(20) # Markers of inner boundary \gamma_{sf}
\end{python}


\subsection{Thermal model}\label{thermal_model}

We define the norm for $\psi \in H^1_r(\omega)$,
\begin{python}
#Computation of H^1_r(\omega) norm
def compute_h1r_norm(psi,mesh):
	r = SpatialCoordinate(mesh)[0]
	dx = Measure('dx', domain = mesh)
	a = inner(psi,psi)*r*dx + inner(grad(psi),grad(psi))*r*dx
	A = assemble(a)
	return sqrt(A)
\end{python}

Next, we define the range of polynomials degree for measuring $p-$convergence and an object to store the relative error.
\begin{python}
error_T_vector = [] #List to store error in temperature w.r.t. polynomial degree
p = range(1,4) # List of polynomial degrees
\end{python}

Next, we specify the relevant physical parameters, which are than later used in variational form.
\begin{python}
k = 10. # Thermal conductivity
h_fluid = 200. # Convection coefficient on \gamma_{sf}
h_right = 2000. # Convection coefficient on \gamma_{out}
h_bottom = 2000. # Convection coefficient on \gamma_{-}
\end{python}

For every polynomial degree, we define the relevant "Lagrange" function space of a particular degree. We also define the solution field and test function in this space.
\begin{python}
# Define function space
VT = FunctionSpace(mesh,"CG",i) # Function space for temperature
psi, T_ = TestFunction(VT), TrialFunction(VT) # Evaluate trial and test function
T = Function(VT, name = "temperature increase")
x = list()
x.append(Expression("x[0]", element=VT.ufl_element())) #r coordinate
x.append(Expression("x[1]", element=VT.ufl_element())) #y coordinate
\end{python}

We then define and solve the weak formulation.
\begin{python}
# solving weak form of energy equation
a_T = k * inner(grad(psi),grad(T_)) * x[0] * dx + \
	h_fluid * psi * T_ * x[0] * d_sf + h_right * psi * T_ * x[0] * d_out + \
	h_bottom * psi * T_ * x[0] * d_bottom # Bilinear side
l_T = h_fluid * psi * (x[0] * x[0] * x[1] + k/h_fluid * ( 2 * x[0] * x[1] * n[0] + x[0] * x[0] * n[1] ) ) * x[0] * d_sf + \
	h_right * psi * (x[0]*x[0]*x[1]+2*x[0]*x[1]*k/h_right) * x[0] * d_out + \
	h_bottom * psi * (x[0] * x[0] * x[1] - x[0] * x[0] * k / h_bottom) * x[0] * d_bottom + \
	-4 * k * x[1] * psi * x[0] * dx + psi * k * x[0] * x[0] * x[0] * ds(12) # Linear side
solve(a_T == l_T, T) # Solve the variational form
\end{python}

After performing the computations, we store the data in format compatible with paraview for further visualization. Also, we plot the $p$-convergence.
\begin{python}
# Plotting and visualization
File("../../benchmarks/result_files/thermal_model/temperature_computed.pvd") << T
File("../../benchmarks/result_files/thermal_model/temperature_analytical.pvd") << T_analytical
error_temperature = Function(VT) #Function for Spatial distribution of temperature absolute error
error_temperature.vector()[:] = abs(T_analytical.vector().get_local() - T.vector().get_local())
File("../../benchmarks/result_files/thermal_model/temperature_absolute_error.pvd") << error_temperature

# Plotting and printing convergence tests
plt.figure(figsize=[10,8])
a = plt.semilogy([1,2,3],error_T_vector,marker='o',linewidth=4)
plt.xticks([1,2,3],fontsize=18)
plt.yticks(fontsize=18)
plt.xlabel('Polynomial degree',fontsize=24)
plt.ylabel('Relative error',fontsize=24)
plt.axis('tight')
plt.savefig("../../benchmarks/result_files/thermal_model/convergence_test")
plt.show()
\end{python}

\subsection{Mechanical model}\label{mechanical_model}

We define the norm for $\overrightarrow{\phi} \in \mathbb{U}$.
\begin{python}
#Computation of \mathbb{U} norm
def compute_U_norm(phi,mesh):
	x = SpatialCoordinate(mesh)
	dx = Measure('dx', domain = mesh)
	a = inner(phi,phi)*x[0]*dx + inner(grad(phi),grad(phi))*x[0]*dx + (phi[0]**2)/x[0]*dx
	A = assemble(a)
	return sqrt(A)
\end{python}

Next, we define the axisymmetric stress and strain tensor.
\begin{python}
# Axisymmetric strain tensor definition. Alternative could be to express strain as vector using Voigt notation.
def eps(u): 
	return \
		sym(as_tensor([[u[0].dx(0), u[0].dx(1), 0. ],\
		[u[1].dx(0), u[1].dx(1), 0.],\
		[0., 0., u[0]/x[0]]]))

# Axisymmetric stress tensor definition. Alternative could be to express stress as vector using Voigt notation.
def sigma(u):
	return lmbda * tr(eps(u)) * Identity(3) + 2.0 * mu * eps(u)
\end{python}

Since, our aim is to assess $p-$convergence, we define the range of polynomial degrees and measure corresponding relative errors.
\begin{python}
error_u_vector = [] #List for absolute error in displacement
p = range(1,4) #Polynomial degrees
\end{python}

We introduce the physical parameters : Young's modulus, Poisson ratio and Lam\'e parameters.
\begin{python}
E = Constant(5e9) # Young's modulus
nu = Constant(0.2) # Poisson's ratio
mu = E/2/(1+nu) # Lam\'e parameter
lmbda = E*nu/(1+nu)/(1-2*nu) # Lam\'e parameter
\end{python}

We now define the function space for displacement and stress. We also initialize variables for the test function and the solution field.
\begin{python}
# Define function space
VM = VectorFunctionSpace(mesh,"CG",i) # Function space for displacement
x = Expression(("x[0]","x[1]"), element=VM.ufl_element())
VS = FunctionSpace(mesh,"CG",max(i-1,1)) 
# Function space for Von Mises stress NOTE: when i=1, the VS is of degree 1 and not 0.
phi, u_ = TestFunction(VM), TrialFunction(VM)
u = Function(VM, name = "Displacement") # u[0] = u_r and u[1] = u_y
\end{python}

Before defining weak formulation, we define the variables related to source term and the boundary data.
\begin{python}
# Dirichlet boundary data
bcs_M = [DirichletBC( VM.sub(0), Constant(0.), 'x[0] < DOLFIN_EPS and on_boundary'), \
	DirichletBC( VM.sub(1), Constant(0.), 'near(x[1],0) and on_boundary')] 
# Set Dirichlet boundary. Note that only functions which satisfy zero normal displacement on \gamma_s \cup \gamma_- are admissible.

# Source term and relevant boundary data
f0_r = - (2*E*nu*1e-4*x[0]/(1-2*nu)/(1+nu)+2*E*1e-4*x[0]/(1+nu)) 
f0_y = - (4*E*1e-4*x[1]/(1+nu)+4*E*1e-4*x[1]*nu/(1-2*nu)/(1+nu)) 

g_plus_r = 2*E*1e-4*x[0]*x[1]/(1+nu)
g_plus_y = E / (1-2*nu) / (1+nu) * (2*nu*1e-4*x[1]*x[1]+(1-nu)*1e-4*x[0]*x[0])

g_minus_r = -g_plus_r

g_sf_r = E / (1-2*nu) / (1+nu) * (1e-4 * x[1] * x[1] + nu * 1e-4 * x[0] * x[0]) * n[0] + 2 * E * 1e-4 * x[0] * x[1] / (1 + nu) * n[1]
g_sf_y = 2 * E * 1e-4 * x[0] * x[1] / (1 + nu) * n[0] + E / (1-2*nu) / (1+nu) * (2 * nu * 1e-4 * x[1] * x[1] + (1 - nu) * 1e-4 * x[0] * x[0]) * n[1]

g_out_r = E / (1-2*nu) / (1+nu) * (1e-4 * x[1] * x[1] + nu * 1e-4 * x[0] * x[0])
g_out_y = 2*E*1e-4*x[0]*x[1]/(1+nu)
\end{python}

The weak form is then defined and solved for computing displacement. Based on this displacement, the Von Mises stress is computed.
\begin{python}
# solving weak form of momentum equation
# Bilinear form
a_M = inner(sigma(u_),eps(phi)) * x[0] * dx
#linear form
l_M = (phi[0] * f0_r + phi[1] * f0_y) * x[0] * dx + (phi[0] * g_plus_r + phi[1] * g_plus_y) * x[0] * ds(12) + \
(phi[0] * g_minus_r) * x[0] * d_bottom + (phi[0] * g_sf_r + phi[1] * g_sf_y) * x[0] * d_sf + \
(phi[0] * g_out_r + phi[1] * g_out_y) * x[0] * d_out
solve(a_M == l_M, u, bcs_M)
\end{python}

\begin{python}
# Von Mises stress computed displacement
sigma_dev = sigma(u) - tr(sigma(u)) / 3 * Identity(3) 
sigma_vm = sqrt(3 * inner( sigma_dev, sigma_dev) / 2) # Von mises stress
# Von Mises stress analytical displacement
sigma_dev_analytical = sigma(u_analytical) - tr(sigma(u_analytical)) / 3 * Identity(3)
sigma_vm_analytical = sqrt(3 * inner( sigma_dev_analytical, sigma_dev_analytical) / 2) # Von mises stress

# Compute H^1_r norm of error
error_u = compute_U_norm(u_analytical-u,mesh)/compute_U_norm(u_analytical,mesh)
error_u_vector.append(error_u)
print("Relative error in U-norm : ",str(error_u))
\end{python}

The data is stored in format compatible to paraview. We also plot the polynomial degree vs the relative error.
\begin{python}
# Post-processing and visualization
File("../../benchmarks/result_files/mechanical_model/displacement_computed.pvd") << u
File("../../benchmarks/result_files/mechanical_model/displacement_analytical.pvd") << u_analytical
File("../../benchmarks/result_files/mechanical_model/displacement_error.pvd") << project(u_analytical-u,VM)

error_stress = Function(VS) #Function for absolute error in stress tensor
error_stress.vector()[:] = abs(project(sigma_vm,VS).vector().get_local() - project(sigma_vm_analytical,VS).vector().get_local())
File("../../benchmarks/result_files/mechanical_model/von_mises_stress_computed.pvd") << project(sigma_vm,VS)
File("../../benchmarks/result_files/mechanical_model/von_mises_stress_analytical.pvd") << project(sigma_vm_analytical,VS)
File("../../benchmarks/result_files/mechanical_model/von_mises_stress_error.pvd") << project(error_stress,VS)

#Convergence tests
plt.figure(figsize=[10,8])
a = plt.semilogy([1,2,3],error_u_vector,marker='o',linewidth=4)
plt.xticks([1,2,3],fontsize=18)
plt.yticks(fontsize=18)
plt.xlabel('Polynomial degree',fontsize=24)
plt.ylabel('Relative error',fontsize=24)
plt.axis('tight')
plt.savefig("../../benchmarks/result_files/mechanical_model/convergence_test")
plt.show() # To show the plots

print("Relative error in U norm: "+ str(error_u_vector))
\end{python}

\subsection{Coupled model}

Similar to the Thermal model (Section \ref{thermal_model}), we first solve the weak form of energy equation.

\begin{python}
# Define function space
VT = FunctionSpace(mesh,"CG",3) # Function space for temperature
psi, T_ = TestFunction(VT), TrialFunction(VT) # Evaluate trial and test function
T = Function(VT, name = "temperature increase")

# Known analytical solution, Thermal material properties and Boundary data
T_analytical = Expression('x[0]*x[0]*x[1]',degree = 3) 
VT_analytical = FunctionSpace(mesh,"CG",3) #Space for analytical solution
T_analytical = project(T_analytical,VT_analytical)
k = 10. # Thermal conductivity
h_fluid = 200. # Convection coefficient on \gamma_{sf}
h_right = 2000. # Convection coefficient on \gamma_{out}
h_bottom = 2000. # Convection coefficient on \gamma_{-}
x = list()
x.append(Expression("x[0]", element=VT.ufl_element())) #r coordinate
x.append(Expression("x[1]", element=VT.ufl_element())) #y coordinate

# solving weak form of energy equation
a_T = k * inner(grad(psi),grad(T_)) * x[0] * dx + \
	h_fluid * psi * T_ * x[0] * d_sf + h_right * psi * T_ * x[0] * d_out + \
	h_bottom * psi * T_ * x[0] * d_bottom # Bilinear side
l_T = h_fluid * psi * (x[0] * x[0] * x[1] + k/h_fluid * ( 2 * x[0] * x[1] * n[0] + x[0] * x[0] * n[1] ) ) * x[0] * d_sf + \
	h_right * psi * (x[0]*x[0]*x[1]+2*x[0]*x[1]*k/h_right) * x[0] * d_out + \
	h_bottom * psi * (x[0] * x[0] * x[1] - x[0] * x[0] * k / h_bottom) * x[0] * d_bottom + \
	-4 * k * x[1] * psi * x[0] * dx + psi * k * x[0] * x[0] * x[0] * ds(12) # Linear side
solve(a_T == l_T, T) # Solve the variational form
\end{python}

Also, similar to mechanical model (section \ref{mechanical_model}) , we define the $\mathbb{U}$ norm, stress and strain tensor. Additionally, we define the thermomechanical stress tensor. 
\begin{python}
# Define \mathbb{U} norm
def compute_U_norm(phi,mesh):
	x = SpatialCoordinate(mesh)
	a = inner(phi,phi)*x[0]*dx + inner(grad(phi),grad(phi))*x[0]*dx + (phi[0]**2/x[0])*dx
	A = assemble(a)
	return sqrt(A)

# Axisymmetric strain tensor definition. Alternative could be to express strain as vector using Voigt notation.
def eps(u):
	return \
		sym(as_tensor([[u[0].dx(0), u[0].dx(1), 0. ],\
		[u[1].dx(0), u[1].dx(1), 0.],\
		[0., 0., u[0]/x[0]]]))

# Axisymmetric thermo-mechanical stress tensor definition. Alternative could be to express as vector using Voigt notation.
def sigma(u,T):
	return lmbda * tr(eps(u)) * Identity(3) + 2.0 * mu * eps(u) - (2 * mu + 3 * lmbda) * alpha * (T - T_0) * Identity(3)

# Axisymmetric mechanical stress tensor definition. Alternative could be to express as vector using Voigt notation.
def sigma2(u):
	return lmbda * tr(eps(u)) * Identity(3) + 2.0 * mu * eps(u)
\end{python}

Next, the physical data is specified.

\begin{python}
T_0 = 298 # Reference temperature for zero thermal stress
E = Constant(5e9) # Young's modulus
nu = Constant(0.2) # Poisson's ratio
mu = E/2/(1+nu) # Lame\'e parameter
lmbda = E*nu/(1+nu)/(1-2*nu) # Lame\'e parameter
alpha = Constant(1e-6) # Thermal expansion coefficient
\end{python}

Similar to the mechanical model (section \ref{mechanical_model}), we solve the weak form.
\begin{python}
# Define function space for displacement
VM = VectorFunctionSpace(mesh,"CG",i) # Function space for displacement
x = Expression(("x[0]","x[1]"), element=VM.ufl_element())
phi, u_ = TestFunction(VM), TrialFunction(VM)
u = Function(VM, name = "Displacement") # u[0] = u_r and u[1] = u_y
VS = FunctionSpace(mesh,"CG",max(i-1,1)) # Function space for shear component of stress

# Dirichlet boundary data
bcs_M = [DirichletBC( VM.sub(0), Constant(0.), 'x[0] < DOLFIN_EPS and on_boundary'), DirichletBC( VM.sub(1), Constant(0.), 'near(x[1],0) and on_boundary')] 

#Boundary and source terms
f0_r = - (2*E*nu*1e-4*x[0]/(1-2*nu)/(1+nu)+2*E*1e-4*x[0]/(1+nu)-2*E*x[0]*x[1]*alpha/(1-2*nu))
f0_y = - (4*E*1e-4*x[1]/(1+nu)+4*E*1e-4*x[1]*nu/(1-2*nu)/(1+nu)-E*x[0]*x[0]*alpha/(1-2*nu))

g_plus_r = 2*E*1e-4*x[0]*x[1]/(1+nu)
g_plus_y = E / (1-2*nu) / (1+nu) * (2*nu*1e-4*x[1]*x[1]+(1-nu)*1e-4*x[0]*x[0]) - E*alpha/(1-2*nu)*(x[0]*x[0]*x[1] - T_0)

g_minus_r = -g_plus_r

g_sf_r = (E / (1-2*nu) / (1+nu) * (1e-4 * x[1] * x[1] + nu * 1e-4 * x[0] * x[0]) - E*alpha/(1-2*nu)*(x[0]*x[0]*x[1] - T_0)) * n[0] + 2 * E * 1e-4 * x[0] * x[1] / (1 + nu) * n[1]
g_sf_y = 2 * E * 1e-4 * x[0] * x[1] / (1 + nu) * n[0] + (E / (1-2*nu) / (1+nu) * (2 * nu * 1e-4 * x[1] * x[1] + (1 - nu) * 1e-4 * x[0] * x[0])- E*alpha/(1-2*nu)*(x[0]*x[0]*x[1] - T_0)) * n[1]

g_out_r = E / (1-2*nu) / (1+nu) * (1e-4 * x[1] * x[1] + nu * 1e-4 * x[0] * x[0]) - E*alpha/(1-2*nu)*(x[0]*x[0]*x[1] - T_0)
g_out_y = 2*E*1e-4*x[0]*x[1]/(1+nu)

# solving weak form of momentum equation
# This is not bilinear side as terms related to thermal stress are included.
a_M1 = inner(sigma(u_,T),eps(phi)) * x[0] * dx
# This is not linear side as terms related to thermal stress are not included.
l_M1 = (phi[0] * f0_r + phi[1] * f0_y) * x[0] * dx + (phi[0] * g_plus_r + phi[1] * g_plus_y) * x[0] * ds(12) + \
(phi[0] * g_minus_r) * x[0] * d_bottom + (phi[0] * g_sf_r + phi[1] * g_sf_y) * x[0] * d_sf + \
(phi[0] * g_out_r + phi[1] * g_out_y) * x[0] * d_out
F = a_M1 - l_M1
a_M = lhs(F) # Now a_M is bilinear form
l_M = rhs(F) # Now l_M is linear form
solve(a_M == l_M, u, bcs_M) # Solve equation

# Compute \mathbb{U} norm of error
error_u = compute_U_norm(u_analytical-u,mesh)/compute_U_norm(u_analytical,mesh)
error_u_vector.append(error_u)
print("Relative error in U-norm : ",str(error_u))
\end{python}

We compute the relevant stress fields.
\begin{python}
# Von Mises stress for computed displacement
sigma_dev = sigma(u,T) - tr(sigma(u,T)) / 3 * Identity(3) 
sigma_vm = sqrt(3 * inner( sigma_dev, sigma_dev) / 2) # Von mises stress
# Von Mises stress for analytical displacement
sigma_dev_analytical = sigma(u_analytical,T) - tr(sigma(u_analytical,T)) / 3 * Identity(3)
sigma_vm_analytical = sqrt(3 * inner( sigma_dev_analytical, sigma_dev_analytical) / 2) # Von mises stress
# Spherical stress for computed displacement
sigma_spherical = tr(sigma(u,T)) / 3
# Spherical stress for analytical displacement
sigma_spherical_analytical = tr(sigma(u_analytical,T)) / 3
# Spherical mechanical stress for computed displacement
sigma_spherical_non_thermal = tr(sigma2(u)) / 3
\end{python}

Finally, we store the solution field for further visualization.
\begin{python}
# Post-processing and visualization
File("../../benchmarks/result_files/coupled_model/Temperature_computed.pvd") << T
File("../../benchmarks/result_files/coupled_model/Temperature_analytical.pvd") << T_analytical
File("../../benchmarks/result_files/coupled_model/Teperature_error.pvd") << project(T-T_analytical,VT)

File("../../benchmarks/result_files/coupled_model/displacement_computed.pvd") << u
File("../../benchmarks/result_files/coupled_model/displacement_analytical.pvd") << u_analytical
File("../../benchmarks/result_files/coupled_model/displacement_absolute_error.pvd") << project(u_analytical - u,VM)

File("../../benchmarks/result_files/coupled_model/von_mises_computed_coupling.pvd") << project(sigma_vm,VS)
File("../../benchmarks/result_files/coupled_model/von_mises_analytical_coupling.pvd") << project(sigma_vm_analytical,VS)
error_stress_von_mises = Function(VS)
error_stress_von_mises.vector()[:] = abs(project(sigma_vm,VS).vector().get_local() - project(sigma_vm_analytical,VS).vector().get_local())
File("../../benchmarks/result_files/coupled_model/von_mises_stress_error_coupling.pvd") << project(error_stress_von_mises,VS)

File("../../benchmarks/result_files/coupled_model/difference_in_spherical_stress.pvd") << project(sigma_spherical - sigma_spherical_non_thermal,VS)
File("../../benchmarks/result_files/coupled_model/thermal_part_of_stress.pvd") << project(-(2 * mu + 3 * lmbda) * alpha * (T - T_0),VS)
error_stress_spherical = Function(VS)
error_stress_spherical.vector()[:] = abs(project(sigma_spherical,VS).vector().get_local() - project(sigma_spherical_non_thermal - (2 * mu + 3 * lmbda) * alpha * (T - T_0),VS).vector().get_local())
File("../../benchmarks/result_files/coupled_model/absolute_error_spherical_stress.pvd") << error_stress_spherical

#Convergence tests
plt.figure(figsize=[10,8])
a = plt.semilogy([1,2,3],error_u_vector,marker='o',linewidth=4)
plt.xticks([1,2,3],fontsize=18)
plt.yticks(fontsize=18)
plt.xlabel('Polynomial degree',fontsize=24)
plt.ylabel('Relative error',fontsize=24)
plt.axis('tight')
plt.savefig('../../benchmarks/result_files/coupled_model/Convergence_coupling_displacement_benchmark_comparison.png')
plt.show()
\end{python}

\subsection{Real case}

We first compute the temperature field and insert it into the weak form of momentum equation. The function space for temperature, test function and temperature solution field are initiated.
\begin{python}
# Function space for temperature
VT = FunctionSpace(mesh,"CG",1) # Function space for temperature
x = list()
x.append(Expression("x[0]", element=VT.ufl_element())) # Read mesh coordinates where x[0] = r and x[1] = y
psi, T_ = TestFunction(VT), TrialFunction(VT)
T = Function(VT, name = "temperature")
\end{python}

We also specify the physical parameters before solving the weak form.
\begin{python}
# Thermal material properties and boundary data
k = 10 # Thermal conductivity
h_fluid = 200 # Convection coefficient h_{c,f}
h_right = 2000 # Convection coefficient h_{c,out}
h_bottom = 2000 # Convection coefficient h_{c,-}
T_right = 313 # Environmental temperature T_{out}
T_fluid = 1773 # Enviromental temperature T_{sf}
T_bottom = 313 # Temperature on Bottom boundary
\end{python}

The weak form for energy equation is specified and solved for computing the temperature field.
\begin{python}
# solving weak form of energy equation
a_T = k * inner(grad(psi),grad(T_)) * x[0] * dx + h_fluid * psi * T_ * x[0] * d_sf + h_right * psi * T_ * x[0] * d_out + h_bottom * psi * T_ * x[0] * d_bottom # bilinear form
l_T = h_fluid * psi * T_fluid * x[0] * d_sf + h_right * psi * T_right * x[0] * d_out + h_bottom * psi * T_bottom * x[0] * d_bottom # linear form
solve(a_T == l_T, T) # solve the equation
\end{python}

Similarly, for the momentum equation, we initiate the function space for displacement, test function and displacement solution field, and specify the physical parameters.
\begin{python}
# # Function space for displacement
VM = VectorFunctionSpace(mesh,"CG",1) # Function space for displacement
x = Expression(("x[0]","x[1]"), element=VM.ufl_element()) # Read mesh coordinates where x[0] = r and x[1] = y
phi, u_ = TestFunction(VM), TrialFunction(VM)
u = Function(VM, name = "Displacement")
\end{python}
\begin{python}
# Mechanical material parameters and imposition of Dirichlet boundary value
T_0 = 298 # Reference temperature
E = Constant(5e9) # Young's modulus
nu = Constant(0.2) # Poission's ratio
mu = E/2/(1+nu) # Lam\' parameter
lmbda = E*nu/(1+nu)/(1-2*nu) # Lam\' parameter
alpha = Constant(1e-6) # Thermal expansion coefficient
W = 0 # weight at top boundary
rho = 7460 # Molten metal density
g = 10. # Gravitation accelaration
p = rho * g * (7.265-x[1]) # Fluid pressure
\end{python}

Additionally, we define the axisymmetric stress and strain tensor.
\begin{python}
# Axisymmetric strain tensor definition. Alternative could be to express stress as vector using Voigt notation.
def eps(u):
	return \
		sym(as_tensor([[u[0].dx(0), u[0].dx(1), 0. ],\
		[u[1].dx(0), u[1].dx(1), 0.],\
		[0., 0., u[0]/x[0]]]))

# Axisymmetric stress tensor definition. Alternative could be to express stress as vector using Voigt notation.
def sigma(u):
	return lmbda * tr(eps(u)) * Identity(3) + 2.0 * mu * eps(u)
\end{python}

We specify than the Dirichlet boundary conditions, weak form for momentum equation and solve the system of equations.
\begin{python}
# Dirichlet boundary data (Displacement).
bcs_M = [DirichletBC( VM.sub(0), Constant(0.), 'x[0] < DOLFIN_EPS and on_boundary'), DirichletBC( VM.sub(1), Constant(0.), 'near(x[1],0) and on_boundary')] 

#solving weak form of momentum equation
a_M = inner(sigma(u_),eps(phi)) * x[0] * dx # bilinear form
l_M = (2 * mu + 3 * lmbda) * alpha * inner((T - T_0) * Identity(3), eps(phi)) * x[0] * dx - dot( phi, W * n) * x[0] * ds(12) - dot( phi, p * n) * x[0] * d_sf # linear form
solve(a_M == l_M, u, bcs_M) # solve variation form
\end{python}

We store the displacement field and temperature field for visualization with paraview.
\begin{python}
# Plotting and visualization
File("../../benchmarks/result_files/actual_problem/Temperature_computed.pvd") << T
File("../../benchmarks/result_files/actual_problem/Displacement.pvd") << u
\end{python}

\subsection{Reduced basis method}

For the affine geometric parametrization, we use 2 decorators : one for the affine Shape Parametrization and the other for transfer of operators between reference domain and parametrized domain.
\begin{python}
@PullBackFormsToReferenceDomain() #Decorator for operator transformation between parameterized domain to reference domain
@AffineShapeParametrization("../../benchmarks/data_files/mesh_data/hearth_vertices_mapping.vmp") #Decorator for shape parametrization with mapping defined in specified file
\end{python}

To compute the temperature field required to compute displacement for coupling model, we use another decorator,
\begin{python}
@ExactParametrizedFunctions() #Decorator for computing temperature field required for linear side
\end{python}

\subsubsection{Thermal system}

We first define the class \emph{HearthThermal}, inherited from \emph{EllipticCoerciveProblem}, for the thermal system.
\begin{python}
class HearthThermal(EllipticCoerciveProblem):
\end{python}

The default initialization involves necessary parameters of the problem.
\begin{python}
	# Default initialization of members
	def __init__(self, V, **kwargs):
		# Call the standard initialization
		EllipticCoerciveProblem.__init__(self, V, **kwargs)
		# ... and also store FEniCS data structures for assembly
		assert "subdomains" in kwargs
		assert "boundaries" in kwargs
		assert "mesh" in kwargs
		assert "h_cf" in kwargs
		assert "h_out" in kwargs
		assert "h_bottom" in kwargs
		self.subdomains, self.boundaries = kwargs["subdomains"], kwargs["boundaries"]
		self.u = TrialFunction(V) 
		self.v = TestFunction(V)
		self.dx = Measure("dx")(subdomain_data=subdomains)
		self.ds = Measure("ds")(subdomain_data=boundaries)
		self.subdomains = subdomains
		self.boundaries = boundaries
		self.reference_mesh = kwargs["mesh"]
		self.h_cf = kwargs["h_cf"]
		self.h_out = kwargs["h_out"]
		self.h_bottom = kwargs["h_bottom"]
		self.x0 = Expression("x[0]", element=V.ufl_element())
\end{python}

Next, the affine mulitplicative terms and weak formulation are defined.
\begin{python}

	# Return theta multiplicative terms of the affine expansion of the problem.
	def compute_theta(self, term):
		mu = self.mu
		if term == "a":
			theta_a0 = mu[10]
			theta_a1 = 1.0
			return (theta_a0, theta_a1)
		elif term == "f":
			theta_f0 = 1.0
			return (theta_f0, )
		else:
			raise ValueError("Invalid term for compute_theta().")

	# Return forms resulting from the discretization of the affine expansion of the problem operators.
	def assemble_operator(self, term):
		u = self.u
		v = self.v
		reference_mesh = self.reference_mesh
		dx = self.dx
		ds = self.ds
		h_cf = self.h_cf
		h_out = self.h_out
		h_bottom = self.h_bottom
		r = self.x0
		d_bottom = ds(2) + ds(3) + ds(4) + ds(5) + ds(6)
		d_out = ds(7) + ds(8) + ds(9) + ds(10) + ds(11)
		d_sf = ds(13) + ds(14) + ds(15) + ds(16) + ds(17) + ds(18) + ds(19) + ds(20)
		if term == "a":
			a0 = inner(grad(u), grad(v))*r*dx
			a1 = h_bottom*u*v*r*d_bottom + h_out*u*v*r*d_out + h_cf*u*v*r*d_sf
			return (a0, a1)
		elif term == "f":
			f0 = h_bottom*313*v*r*d_bottom + h_out*313*v*r*d_out + h_cf*1773*v*r*d_sf
			return (f0, )
		elif term == "inner_product":
			x0 = u*v*r*dx + inner(grad(u), grad(v))*r*dx
			return (x0,)
		else:
			raise ValueError("Invalid term for assemble_operator().")
\end{python}

Using the \emph{HearthThermal} class we now perform POD-Galerkin approximation of the thermal problem. The function space is defined first. Next, an instant of \emph{HearthThermal} class, \emph{hearth\_problem\_thermal} is created and reduction with POD-Galerkin method is performed.
\begin{python}
# 2A. Create Finite Element space (Lagrange P1)
VT = FunctionSpace(mesh, "Lagrange", 1) # For temperature

# 3A. Allocate an object of the Hearth class
hearth_problem_thermal = HearthThermal(VT, subdomains=subdomains, boundaries=boundaries, mesh=mesh, h_cf=200., h_out=2000., h_bottom=2000.)
#specify and set range of each parameter
mu_range = [(2.3,2.4), (0.5,0.7), (0.5,0.7), (0.4,0.6), (3.05,3.35), (13.5,14.5), (8.3,8.7), (8.8,9.2), (9.8,10.2), (10.4,10.8), (9.8,10.2), (2.08e9,2.08e9), (1.39e9,1.39e9), (1e-6,1e-6)]
hearth_problem_thermal.set_mu_range(mu_range)

# 4A. Prepare reduction with a POD-Galerkin method
#NOTE : truth_problem attribute is FEM problem and reduced_problem is RB problem
pod_galerkin_method_thermal = PODGalerkin(hearth_problem_thermal)
pod_galerkin_method_thermal.set_Nmax(100) #Maximum size of reduced basis space
pod_galerkin_method_thermal.set_tolerance(1e-4) #Maximum eigenvalue tolerance
\end{python}

After computing the full order model solution for Coupling thermomechanical model, we perform the offline phase of thermal system.
\begin{python}
# 5A. Perform the offline phase
pod_galerkin_method_thermal.initialize_training_set(1000) #Initialize training set with specified number of training parameters
reduced_hearth_problem_thermal = pod_galerkin_method_thermal.offline() #Perform offline phase
\end{python}

Next, we perform the error analysis, compute the time taken for truth solution and reduced solution.
\begin{python}
# 7A. Perform an error analysis
pod_galerkin_method_thermal.initialize_testing_set(50) #Initialize error analysis with specified number of parameters
pod_galerkin_method_thermal.error_analysis() #Perform error analysis

# 8A1. Perform a speedup analysis - Compute time for truth solutions
pod_galerkin_method_thermal.initialize_testing_set(50) #Initialize truth time computation with specified number of parameters
testing_set_speedup_analysis = pod_galerkin_method_thermal.testing_set

pod_galerkin_method_thermal._patch_truth_solve(True) #To enable cahce reading

truth_timer = Timer("parallel") #Timer for computation of FEM solution
time_thermal_truth = np.empty(len(testing_set_speedup_analysis)) #Storage of time taken for solving FEM equation. It is a vector of size of number of speedup analysis parameters

# Iteration over speedup analysis parameters for measuring time taken for FEM solution
for (mu_index, mu_test) in enumerate(testing_set_speedup_analysis):
	print(TextLine(str(mu_index), fill="#"))
	pod_galerkin_method_thermal.truth_problem.set_mu(mu_test) #Set the parameter
	truth_timer.start()
	pod_galerkin_method_thermal.truth_problem.solve() #Solve the FEM problem
	truth_time_thermal = truth_timer.stop()
	print("Truth time thermal : ",truth_time_thermal)
	time_thermal_truth[mu_index] = truth_time_thermal #Save time taken for truth solve

np.save("time_thermal_truth",time_thermal_truth) #Save time taken for computation of FEM solution

pod_galerkin_method_thermal._undo_patch_truth_solve(True) #To enable cache reading

# 8A2. Perform a speedup analysis - Compute time for reduced solutions
pod_galerkin_method_thermal._patch_truth_solve(True) #To disable cache reading
reduced_timer = Timer("serial") #Timer for computation of RB solution
max_basis_function = reduced_hearth_problem_thermal.N #Size of reduced basis space
time_thermal_reduced = np.empty([max_basis_function,len(testing_set_speedup_analysis)]) #Storage of time taken for solving RB equation. It is a matrix of size size of reduced basis space \times number of speedup analysis parameters

# Iteration over speedup analysis parameters for measuring time for RB solution
for basis_size in range(1,max_basis_function+1):
	for (mu_index, mu_test) in enumerate(testing_set_speedup_analysis):
		print(TextLine(str(mu_index), fill="#"))
		pod_galerkin_method_thermal.reduced_problem.set_mu(mu_test) #Set parameter
		reduced_timer.start()
		pod_galerkin_method_thermal.reduced_problem.solve(basis_size) #Solve the RB problem
		rb_time_thermal = reduced_timer.stop()
		print("Reduced time thermal : ",rb_time_thermal)
		time_thermal_reduced[basis_size-1,mu_index] = rb_time_thermal #Save time taken for RB solve

pod_galerkin_method_thermal._undo_patch_truth_solve(True) #To disable cache reading

np.save("time_thermal_reduced",time_thermal_reduced) #Save time taken for computation for RB solution
\end{python}

For any new parameter \emph{online\_mu}, the full order model solution and reduced basis solution can be performed using these classes.
\begin{python}
pod_galerkin_method_thermal.reduced_problem.set_mu(online_mu) #Set parameter
T_rb = pod_galerkin_method_thermal.reduced_problem.solve() #Reduced problem solve
pod_galerkin_method_thermal.reduced_problem.export_solution(filename="reference_domain_thermal_rb") #Save solution for visualization with paraview
T_rb = pod_galerkin_method_thermal.reduced_problem.basis_functions * T_rb #RB solution projected back to FEM space
pod_galerkin_method_thermal.truth_problem.set_mu(online_mu) #Set parameter
T = pod_galerkin_method_thermal.truth_problem.solve() #FEM problem solve
pod_galerkin_method_thermal.truth_problem.export_solution(filename="reference_domain_fem") #Save solution for visualization with paraview
pod_galerkin_method_thermal.truth_problem.mesh_motion.move_mesh() #Deform mesh as per geometric parameters
File("HearthThermal/reference_domain_thermal_spatial_error.pvd") << project(T-T_rb,VT) #Spatial error
pod_galerkin_method_thermal.truth_problem.mesh_motion.reset_reference() #Restore mesh to reference configuration
\end{python}

\subsubsection{Mechanical system}

We first define the class \emph{HearthMechanical}, inherited from \emph{EllipticCoerciveProblem}, for the mechanical system.
\begin{python}
class HearthMechanical(EllipticCoerciveProblem):
\end{python}

We specify the default initialization for this class. 
\begin{python}
	# Default initialization of members
	def __init__(self, V, **kwargs):
		# Call the standard initialization
		EllipticCoerciveProblem.__init__(self, V, **kwargs)
		# ... and also store FEniCS data structures for assembly
		assert "subdomains" in kwargs
		assert "boundaries" in kwargs
		assert "mesh" in kwargs
		self.normal = as_vector(FacetNormal(kwargs["mesh"]))
		self.subdomains, self.boundaries = kwargs["subdomains"], kwargs["boundaries"]
		self.u = TrialFunction(V)
		self.v = TestFunction(V)
		self.dx = Measure("dx")(subdomain_data=subdomains)
		self.ds = Measure("ds")(subdomain_data=boundaries)
		self.subdomains = subdomains
		self.boundaries = boundaries
		self.x0 = Expression("x[0]", element=V.sub(0).ufl_element())
		self.x1 = Expression("x[1]", element=V.sub(1).ufl_element())
\end{python}

Next, the affine multiplicative terms, weak forms and strain tensors are defined.
\begin{python}
	# Return theta multiplicative terms of the affine expansion of the problem.
	def compute_theta(self, term):
		mu = self.mu
		if term == "a":
			theta_a0 = mu[11]
			theta_a1 = 2*mu[12]
			return (theta_a0, theta_a1, )
		elif term == "f":
			theta_f0 = 1.0
			return (theta_f0, )
		else:
			raise ValueError("Invalid term for compute_theta().")

	# Return strain tensor
	def strain(self,u):
		r = self.x0
		return sym(as_tensor([[u[0].dx(0), u[0].dx(1), 0. ], [u[1].dx(0), u[1].dx(1), 0.], [0., 0., u[0]/r]]))

	# Return forms resulting from the discretization of the affine expansion of the problem operators.
	def assemble_operator(self, term):
		u = self.u
		v = self.v
		dx = self.dx
		ds = self.ds
		r = self.x0
		x1 = self.x1
		n = self.normal
		d_bottom = ds(2) + ds(3) + ds(4) + ds(5) + ds(6)
		d_out = ds(7) + ds(8) + ds(9) + ds(10) + ds(11)
		d_sf = ds(13) + ds(14) + ds(15) + ds(16) + ds(17) + ds(18) + ds(19) + ds(20)
		if term == "a":
			a0 = (u[0].dx(0)+u[1].dx(1)+u[0]/r)*(v[0].dx(0)+v[1].dx(1)+v[0]/r)*r*dx
			a1 = (u[0].dx(0)*v[0].dx(0) + u[1].dx(1)*v[1].dx(1) + (u[0]*v[0])/(r)**2 + 0.5*(u[0].dx(1)+u[1].dx(0))*(v[0].dx(1)+v[1].dx(0))) * r * dx
			return (a0, a1,)
		elif term == "f":
			f0 = - dot( v, 7460*9.81*(7.265-x1)*n) * r * d_sf
			return (f0,)
		elif term == "inner_product":
			x0 = inner(u,v) * r * dx + inner(self.strain(u),self.strain(v)) * r * dx
			return (x0,)
		elif term == "dirichlet_bc":
			bc0 = [DirichletBC(self.V.sub(0), Constant(0.), self.boundaries, 1),
				DirichletBC(self.V.sub(1), Constant(0.), self.boundaries, 2),
				DirichletBC(self.V.sub(1), Constant(0.), self.boundaries, 3),
				DirichletBC(self.V.sub(1), Constant(0.), self.boundaries, 4),
				DirichletBC(self.V.sub(1), Constant(0.), self.boundaries, 5),
				DirichletBC(self.V.sub(1), Constant(0.), self.boundaries, 6),]
			return (bc0,)
		else:
			raise ValueError("Invalid term for assemble_operator().")
\end{python}

The function space and an instant of \emph{HearthMechanical} class that is \emph{hearth\_problem\_mechanical} are defined. 
\begin{python}
# 2B. Create Finite Element space (Lagrange P1)
VM = VectorFunctionSpace(mesh,"Lagrange",1) # For mechanical

# 3B. Allocate an object of the HearthThermoMechanical class
hearth_problem_mechanical = HearthMechanical(VM, subdomains=subdomains, boundaries=boundaries, mesh=mesh)
#specify and set range of each parameter
mu_range = [(2.3,2.4), (0.5,0.7), (0.5,0.7), (0.4,0.6), (3.05,3.35), (13.5,14.5), (8.3,8.7), (8.8,9.2), (9.8,10.2), (10.4,10.8), (10.,10.), (1.9e9,2.5e9), (1.2e9,1.8e9), (1e-6,1e-6)]
hearth_problem_mechanical.set_mu_range(mu_range)
\end{python}

Next, reduction with POD-Galerkin method is performed and offline phase is performed.
\begin{python}
# 4B. Prepare reduction with a POD-Galerkin method
#NOTE : truth_problem attribute is FEM problem and reduced_problem is RB problem
pod_galerkin_method_mechanical = PODGalerkin(hearth_problem_mechanical)
pod_galerkin_method_mechanical.set_Nmax(100) #Maximum size of reduced basis space
pod_galerkin_method_mechanical.set_tolerance(1e-4) #Maximum eigenvalue tolerance

# 5B. Perform the offline phase
pod_galerkin_method_mechanical.initialize_training_set(1000) #Initialize training set with specified number of training parameters
reduced_hearth_problem_mechanical = pod_galerkin_method_mechanical.offline() #Perform offline phase
\end{python}

Error analysis is performed and time taken for computation of truth solution and reduced basis solution are measured.
\begin{python}
# 7B. Perform an error analysis
pod_galerkin_method_mechanical.initialize_testing_set(50) #Initialize error analysis set with specified number of parameters
pod_galerkin_method_mechanical.error_analysis() #Perform error analysis

# 8B1. Perform a speedup analysis - Compute time for truth solutions
pod_galerkin_method_mechanical.initialize_testing_set(50) #Initialize speedup analysis set with specified number of parameters
testing_set_speedup_analysis = pod_galerkin_method_mechanical.testing_set

pod_galerkin_method_mechanical._patch_truth_solve(True) # To disable cache reading

truth_timer = Timer("parallel") #Timer for computation of FEM solution
time_mechanical_truth = np.empty(len(testing_set_speedup_analysis)) #Storage of time taken for solving FEM equation. It is a vector of size of number of speedup analysis parameters

# Iteration over speedup analysis parameters for measuring time taken for FEM solution
for (mu_index, mu_test) in enumerate(testing_set_speedup_analysis):
	print(TextLine(str(mu_index), fill="#"))
	pod_galerkin_method_mechanical.truth_problem.set_mu(mu_test) #Set the parameter
	truth_timer.start()
	pod_galerkin_method_mechanical.truth_problem.solve() #Solve the FEM problem
	truth_time_mechanical = truth_timer.stop()
	print("Truth time mechanical : ",truth_time_mechanical)
	time_mechanical_truth[mu_index] = truth_time_mechanical #Save time taken for truth solve

pod_galerkin_method_mechanical._undo_patch_truth_solve(True) #To enable cache reading

np.save("time_mechanical_truth",time_mechanical_truth) #Save numpy array of time taken for FEM solution

# 8B2. Perform a speedup analysis - Compute time for reduced solutions
pod_galerkin_method_mechanical._patch_truth_solve(True) #To disable cache reading

reduced_timer = Timer("serial") #Timer for computation of reduced solution
max_basis_function = reduced_hearth_problem_mechanical.N # Size of reduced basis space
time_mechanical_reduced = np.empty([max_basis_function,len(testing_set_speedup_analysis)]) #Storage of time taken for solving RB equation. It is a matrix of size size of reduced basis space \times number of speedup analysis parameters

# Iteration over speedup analysis parameters for measuring time taken for RB solution
for basis_size in range(1,max_basis_function+1):
	for (mu_index, mu_test) in enumerate(testing_set_speedup_analysis):
		print(TextLine(str(mu_index), fill="#"))
		pod_galerkin_method_mechanical.reduced_problem.set_mu(mu_test) #Set the parameter
		reduced_timer.start()
		pod_galerkin_method_mechanical.reduced_problem.solve(basis_size) #Solve the RB problem
		rb_time_mechanical = reduced_timer.stop()
		print("Reduced time mechanical : ",rb_time_mechanical)
		time_mechanical_reduced[basis_size-1,mu_index] = rb_time_mechanical #Save time taken for reduced basis solution

pod_galerkin_method_mechanical._undo_patch_truth_solve(True) #To enable cache reading

np.save("time_mechanical_reduced",time_mechanical_reduced) #Save numpy array of time taken for RB solution
\end{python}

For any new parameter \emph{online\_mu}, the FEM solution and reduced basis solution are computed as:
\begin{python}
# 6B. Perform an online solve
pod_galerkin_method_mechanical.reduced_problem.set_mu(online_mu) #Set parameter
u_rb = pod_galerkin_method_mechanical.reduced_problem.solve() #Reduced problem solve
pod_galerkin_method_mechanical.reduced_problem.export_solution(filename="reference_domain_mechanical_rb") #Save solution for visualization with paraview
u_rb = pod_galerkin_method_mechanical.reduced_problem.basis_functions * u_rb #RB solution projected back to FEM space
pod_galerkin_method_mechanical.truth_problem.set_mu(online_mu) #Set parameter
u = pod_galerkin_method_mechanical.truth_problem.solve() #FEM problem solve
pod_galerkin_method_mechanical.truth_problem.export_solution(filename="reference_domain_fem") #Save solution for visualization with paraview
pod_galerkin_method_mechanical.truth_problem.mesh_motion.move_mesh() #Deform mesh as per geometric parameters
File("HearthMechanical/reference_domain_mechanical_spatial_error.pvd") << project(u-u_rb,VM) #Spatial error
pod_galerkin_method_mechanical.truth_problem.mesh_motion.reset_reference() #Restore mesh to reference configuration
\end{python}

\subsubsection{Coupling system}

For the coupling system, we define the class \emph{HearthThermoMechanical}.
\begin{python}
class HearthThermoMechanical(EllipticCoerciveProblem):
\end{python}

The default initialization is specified,
\begin{python}
	# Default initialization of members
	def __init__(self, V, **kwargs):
		# Call the standard initialization
		EllipticCoerciveProblem.__init__(self, V, **kwargs)
		# ... and also store FEniCS data structures for assembly
		assert "subdomains" in kwargs
		assert "boundaries" in kwargs
		assert "mesh" in kwargs
		assert "hearth_problem_thermal" in kwargs
		assert "ref_temperature" in kwargs
		self.subdomains, self.boundaries = kwargs["subdomains"], kwargs["boundaries"]
		self.u = TrialFunction(V)
		self.v = TestFunction(V)
		self.dx = Measure("dx")(subdomain_data=subdomains)
		self.ds = Measure("ds")(subdomain_data=boundaries)
		self.subdomains = subdomains
		self.boundaries = boundaries
		self.hearth_problem_thermal = kwargs["hearth_problem_thermal"]
		self.T_0 = kwargs["ref_temperature"]
		self.x0 = Expression("x[0]", element=V.sub(0).ufl_element())
\end{python}

Similar to mechanical system, we define the affine mutiplicative terms, weak formulation and strain tensor.
\begin{python}
	# Return theta multiplicative terms of the affine expansion of the problem.
	def compute_theta(self, term):
		mu = self.mu
		if term == "a":
			theta_a0 = mu[11]
			theta_a1 = 2*mu[12]
			return (theta_a0, theta_a1,)
		elif term == "f":
			theta_f0 = (2 * mu[11] + 3 * mu[12]) * mu[13]
			return (theta_f0,)
		else:
			raise ValueError("Invalid term for compute_theta().")

	# Return strain tensor
	def strain(self,u):
		r = self.x0
		return sym(as_tensor([[u[0].dx(0), u[0].dx(1), 0. ], [u[1].dx(0), u[1].dx(1), 0.], [0., 0., u[0]/r]]))

	# Return forms resulting from the discretization of the affine expansion of the problem operators.
	def assemble_operator(self, term):
		u = self.u
		v = self.v
		dx = self.dx
		ds = self.ds
		T_0 = self.T_0
		T = self.hearth_problem_thermal._solution
		r = self.x0
		d_bottom = ds(2) + ds(3) + ds(4) + ds(5) + ds(6)
		d_out = ds(7) + ds(8) + ds(9) + ds(10) + ds(11)
		d_sf = ds(13) + ds(14) + ds(15) + ds(16) + ds(17) + ds(18) + ds(19) + ds(20)
		if term == "a":
			a0 = (u[0].dx(0)+u[1].dx(1)+u[0]/r)*(v[0].dx(0)+v[1].dx(1)+v[0]/r)*r*dx
			a1 = (u[0].dx(0)*v[0].dx(0) + u[1].dx(1)*v[1].dx(1) + (u[0]*v[0])/(r)**2 + 0.5*(u[0].dx(1)+u[1].dx(0))*(v[0].dx(1)+v[1].dx(0))) * r * dx
			return (a0, a1,)
		elif term == "f":
			f0 = (T-T_0) * (v[0].dx(0) + v[1].dx(1) + v[0]/r) * r * dx
			return (f0,)
		elif term == "inner_product":
			x0 = inner(u,v) * r * dx + inner(self.strain(u),self.strain(v)) * r * dx
			return (x0,)
		elif term == "dirichlet_bc":
			bc0 = [DirichletBC(self.V.sub(0), Constant(0.), self.boundaries, 1),
				DirichletBC(self.V.sub(1), Constant(0.), self.boundaries, 2),
				DirichletBC(self.V.sub(1), Constant(0.), self.boundaries, 3),
				DirichletBC(self.V.sub(1), Constant(0.), self.boundaries, 4),
				DirichletBC(self.V.sub(1), Constant(0.), self.boundaries, 5),
				DirichletBC(self.V.sub(1), Constant(0.), self.boundaries, 6),]
			return (bc0,)
		else:
			raise ValueError("Invalid term for assemble_operator().")
\end{python}

We define an instant of \emph{HearthThermoMechanical} class and perform reduction with POD-Galerkin method.
\begin{python}
# 3C. Allocate an object of the HearthThermoMechanical class
hearth_problem_thermo_mechanical = HearthThermoMechanical(VM, subdomains=subdomains, boundaries=boundaries, mesh=mesh, hearth_problem_thermal=hearth_problem_thermal, ref_temperature=T_0)
#specify and set range of each parameter
mu_range = [(2.3,2.4), (0.5,0.7), (0.5,0.7), (0.4,0.6), (3.05,3.35), (13.5,14.5), (8.3,8.7), (8.8,9.2), (9.8,10.2), (10.4,10.8), (9.8,10.2), (1.9e9,2.5e9), (1.2e9,1.8e9), (0.8e-6,1.2e-6)]
hearth_problem_thermo_mechanical.set_mu_range(mu_range)

# 4C. Prepare reduction with a POD-Galerkin method
#NOTE : truth_problem attribute is FEM problem and reduced_problem is RB problem
pod_galerkin_method_thermo_mechanical = PODGalerkin(hearth_problem_thermo_mechanical)
pod_galerkin_method_thermo_mechanical.set_Nmax(100) #Maximum size of reduced basis space
pod_galerkin_method_thermo_mechanical.set_tolerance(1e-4) #Maximum eigenvalue tolerance
\end{python}

Next, we perform the offline phase.
\begin{python}
# 5C. Perform the offline phase
pod_galerkin_method_thermo_mechanical.initialize_training_set(1000) #Initialize training set with specified number of training parameters
reduced_hearth_problem_thermo_mechanical = pod_galerkin_method_thermo_mechanical.offline() #Perform offline phase
\end{python}

Before performing the reduction of thermal problem, we perform the truth solution computation related operations. This is due to the reason that, we want to use temperature computed by FEM solution for the truth solution of displacement.
We compute the truth solution at few parameter, truth solution for error analysis and measure time taken for computing the truth solution.
\begin{python}
# 6C. Perform a truth solve : Reference domain
online_mu = ( 2.365, 0.6, 0.6, 0.5, 3.2, 14.10, 8.50, 9.2, 9.9, 10.6, 10., lame1, lame2, 1e-6)
pod_galerkin_method_thermo_mechanical.truth_problem.set_mu(online_mu)
u_ref = pod_galerkin_method_thermo_mechanical.truth_problem.solve()
pod_galerkin_method_thermo_mechanical.truth_problem.export_solution(filename="reference_domain_fem")

# 6C. Perform a truth solve : Parametrized domain
online_mu = ( 2.365, 0.6, 0.6, 0.45, 3.2, 14.10, 8.30, 9.2, 9.9, 10.6, 10., lame1, lame2, 1e-6)
pod_galerkin_method_thermo_mechanical.truth_problem.set_mu(online_mu)
u_par = pod_galerkin_method_thermo_mechanical.truth_problem.solve()
pod_galerkin_method_thermo_mechanical.truth_problem.export_solution(filename="parametric_domain_fem")

# 7C1. Perform an error analysis - Compute truth solutions
pod_galerkin_method_thermo_mechanical.initialize_testing_set(50) #Initialize error analysis set with specified number of parameters
testing_set_error_analysis = pod_galerkin_method_thermo_mechanical.testing_set 

truth_solution_thermo_mechanical = list()

# Iteration over error analysis parameters for measuring time taken for FEM solution
for (mu_index, mu_test) in enumerate(testing_set_error_analysis):
	print(TextLine(str(mu_index), fill="#"))
	pod_galerkin_method_thermo_mechanical.truth_problem.set_mu(mu_test) #Set parameter
	truth_solution_thermo_mechanical.append(pod_galerkin_method_thermo_mechanical.truth_problem.solve()) #Solve and store FEM solution

# 8C1. Perform a speedup analysis - Compute time for truth solutions
pod_galerkin_method_thermo_mechanical.initialize_testing_set(50) #Initialize truth solution with specified number of parameters
testing_set_speedup_analysis = pod_galerkin_method_thermo_mechanical.testing_set

pod_galerkin_method_thermo_mechanical._patch_truth_solve(True) #To disable cache reading

truth_timer = Timer("parallel") #Timer for computation of FEM solution
time_thermo_mechanical_truth = np.empty(len(testing_set_speedup_analysis)) #Storage of time taken for solving FEM equation. It is a vector of size of number of speedup analysis parameters

# Iteration over speedup analysis parameters for measuring time taken for RB solution
for (mu_index, mu_test) in enumerate(testing_set_speedup_analysis):
	print(TextLine(str(mu_index), fill="#"))
	pod_galerkin_method_thermo_mechanical.truth_problem.set_mu(mu_test) #Set the parameter
	truth_timer.start()
	pod_galerkin_method_thermo_mechanical.truth_problem.solve() #Solve the RB problem
	truth_time_thermo_mechanical = truth_timer.stop()
	print("Truth time thermomechanical : ",truth_time_thermo_mechanical)
	time_thermo_mechanical_truth[mu_index] = truth_time_thermo_mechanical #Save time taken for reduced basis solution

pod_galerkin_method_thermo_mechanical._undo_patch_truth_solve(True) #To disable cache reading

np.save("time_thermo_mechanical_truth",time_thermo_mechanical_truth) #Save numpy array of time taken for RB solution
\end{python}

Now, since the operations related to truth solution are performed, we can reduce the thermal system. The reduced solution of temperature field is used for computing reduced solution at few paraneters. Also we compute reduced solution for error analysis and time taken for computing reduced solution.
\begin{python}
#6C. Perform an online solve : Reference domain
online_mu_reference = ( 2.365, 0.6, 0.6, 0.5, 3.2, 14.10, 8.50, 9.2, 9.9, 10.6, 10., lame1, lame2, 1e-6)
online_mu = online_mu_reference
pod_galerkin_method_thermo_mechanical.reduced_problem.set_mu(online_mu)
u_rb = pod_galerkin_method_thermo_mechanical.reduced_problem.solve()
pod_galerkin_method_thermo_mechanical.reduced_problem.export_solution(filename="reference_domain_thermomechanical_rb")
u_rb = pod_galerkin_method_thermo_mechanical.reduced_problem.basis_functions * u_rb
pod_galerkin_method_thermo_mechanical.truth_problem.mesh_motion.move_mesh()
File("HearthThermoMechanical/reference_domain_thermomechanical_spatial_error.pvd") << project(u_ref-u_rb,VM)
pod_galerkin_method_thermo_mechanical.truth_problem.mesh_motion.reset_reference()

# 6C. Perform an online solve : Parametrized domain
online_mu_parametrized = ( 2.365, 0.6, 0.6, 0.45, 3.2, 14.10, 8.30, 9.2, 9.9, 10.6, 10., lame1, lame2, 1e-6)
online_mu = online_mu_parametrized
pod_galerkin_method_thermo_mechanical.reduced_problem.set_mu(online_mu)
u_rb = pod_galerkin_method_thermo_mechanical.reduced_problem.solve()
pod_galerkin_method_thermo_mechanical.reduced_problem.export_solution(filename="parametric_domain_thermomechanical_rb")
u_rb = pod_galerkin_method_thermo_mechanical.reduced_problem.basis_functions * u_rb
pod_galerkin_method_thermo_mechanical.truth_problem.mesh_motion.move_mesh()
File("HearthThermoMechanical/parametric_domain_thermomechanical_spatial_error.pvd") << project(u_par-u_rb,VM)
pod_galerkin_method_thermo_mechanical.truth_problem.mesh_motion.reset_reference()

# 7C2. Perform an error analysis - Compute reduced basis solution
dx = Measure("dx")(subdomain_data=subdomains) #Volume measure
r = Expression("x[0]", element=VM.sub(0).ufl_element()) # 

max_basis_function = reduced_hearth_problem_thermo_mechanical.N # Size of reduced basis space
error_thermo_mechanical = np.empty([max_basis_function,len(testing_set_error_analysis)]) # Numpy array of size of reduced basis space \times number of error analysis parameters for storing error
# Iteration over error analysis parameters for measuring time taken for RB solution
for basis_size in range(1,max_basis_function+1):
	for (mu_index, mu_test) in enumerate(testing_set_error_analysis):
		print(TextLine(str(mu_index), fill="#"))
		pod_galerkin_method_thermo_mechanical.reduced_problem.set_mu(mu_test) #Set parameter
		rb_dofs = pod_galerkin_method_thermo_mechanical.reduced_problem.solve(basis_size) #Compute reduced basis degrees of freddom
		rb_solution = reduced_hearth_problem_thermo_mechanical.basis_functions[:basis_size] * rb_dofs #RB solution projected back to FEM space
		# Absolute and relative error measurement
		absolute_error = assemble(inner(truth_solution_thermo_mechanical[mu_index] - rb_solution,truth_solution_thermo_mechanical[mu_index] - rb_solution) * r * dx + inner(hearth_problem_thermo_mechanical.strain(truth_solution_thermo_mechanical[mu_index] - rb_solution), hearth_problem_thermo_mechanical.strain(truth_solution_thermo_mechanical[mu_index] - rb_solution)) * r * dx)
		error_thermo_mechanical[basis_size-1,mu_index] = np.sqrt(absolute_error / assemble(inner(truth_solution_thermo_mechanical[mu_index],truth_solution_thermo_mechanical[mu_index]) * r * dx + inner(hearth_problem_thermo_mechanical.strain(truth_solution_thermo_mechanical[mu_index]), hearth_problem_thermo_mechanical.strain(truth_solution_thermo_mechanical[mu_index])) * r * dx))

np.save("HearthThermoMechanical/error_analysis/error_thermo_mechanical",error_thermo_mechanical)

# 8C2. Perform a speedup analysis - Compute time for reduced solutions
pod_galerkin_method_thermo_mechanical._patch_truth_solve(True) #To disable cache reading

reduced_timer = Timer("serial") #Timer for computation of RB solution
time_thermo_mechanical_reduced = np.empty([max_basis_function,len(testing_set_speedup_analysis)]) #Storage of time taken for solving RB equation. It is a matrix of size size of reduced basis space \times number of speedup analysis parameters

# Iteration over speedup analysis parameters for measuring time taken for RB solution
for basis_size in range(1,max_basis_function+1):
	for (mu_index, mu_test) in enumerate(testing_set_speedup_analysis):
		print(TextLine(str(mu_index), fill="#"))
		pod_galerkin_method_thermo_mechanical.reduced_problem.set_mu(mu_test) #Set parameter
		reduced_timer.start()
		pod_galerkin_method_thermo_mechanical.reduced_problem.solve(basis_size) #Solve the RB problem
		rb_time_thermo_mechanical = reduced_timer.stop()
		print("Reduced time thermomechanical : ",rb_time_thermo_mechanical)
		time_thermo_mechanical_reduced[basis_size-1,mu_index] = rb_time_thermo_mechanical #Save time taken for reduced basis solution

pod_galerkin_method_thermo_mechanical._undo_patch_truth_solve(True) # To disable cache reading

np.save("time_thermo_mechanical_reduced",time_thermo_mechanical_reduced) #Save numpy array of time taken for RB solution
\end{python}

\section{License}

\begin{itemize}
\item FEniCS and RBniCS are freely available under the GNU LGPL, version 3.
\item Matplotlib only uses BSD compatible code, and its license is based on the PSF license. Non-BSD compatible licenses (e.g., LGPL) are acceptable in matplotlib toolkits.
\end{itemize}

Accordingly, this code is freely available under the GNU LGPL, version 3.

\section{Disclaimer}

In downloading this SOFTWARE you are deemed to have read and agreed to the following terms: This SOFT- WARE has been designed with an exclusive focus on civil applications. It is not to be used for any illegal, deceptive, misleading or unethical purpose or in any military applications. This includes ANY APPLICATION WHERE THE USE OF THE SOFTWARE MAY RESULT IN DEATH, PERSONAL INJURY OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE. Any redistribution of the software must retain this disclaimer. BY INSTALLING, COPYING, OR OTHERWISE USING THE SOFTWARE, YOU AGREE TO THE TERMS ABOVE. IF YOU DO NOT AGREE TO THESE TERMS, DO NOT INSTALL OR USE THE SOFTWARE.
